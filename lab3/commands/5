WITH RECURSIVE river_path AS (
    -- base case
    SELECT 
        r.name,
        main_r.length + r.length AS total_length,       -- store mainriver length in total_length
        ARRAY[r.river, r.name]::character varying[] AS visited,
        1 AS rank
    FROM 
        river r
    JOIN
        river main_r ON main_r.name = r.river       -- retrieve length of main river 
    WHERE 
        r.river IN ('Nile', 'Amazonas', 'Yangtze', 'Rhein', 'Donau', 'Mississippi')
    
    UNION ALL

    SELECT 
        r.name,
        rp.total_length + r.length AS length,
        rp.visited || r.name AS visited,
        rp.rank + 1 AS rank
    FROM 
        river_path rp
    JOIN
        river r ON r.river = rp.name 
    WHERE 
        NOT r.name = ANY (rp.visited)
),

longest_branches AS (
    SELECT 
        rp.visited[1] AS main_river,
        rp.name,
        rp.total_length,
        rp.rank,
        rp.visited,
        array_length(rp.visited, 1) AS river_count
    FROM 
        river_path rp
),

maximum_ranks AS (
    SELECT  
        lb.main_river,
        MAX(rank) AS max_rank
    FROM 
        longest_branches lb
    GROUP BY 
        lb.main_river
)

-- SELECT 
--     *
-- FROM 
--     maximum_ranks
-- ORDER BY    
--     max_rank;

SELECT
    lb.rank AS rank,
    array_to_string(lb.visited, ' - ') AS river_path,
    lb.river_count AS numRivers,
    lb.total_length AS total_length
FROM 
    longest_branches lb
JOIN    
    maximum_ranks mr ON mr.max_rank = lb.rank AND mr.main_river = lb.visited[1]
ORDER BY 
    lb.rank, lb.total_length DESC;